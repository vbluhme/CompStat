---
title: "Bivariate Smoothing (document)"
author: "Viktor Bluhme Jeppesen and Malte Nikolajsen"
date: "9/8/2020"
output: html_document
---

```{r setup, include=FALSE}
library(tidyverse)
library(splines)

knitr::opts_chunk$set(cache = TRUE, dev.args = list(bg = 'transparent'), 
                      fig.align = "center", fig.pos="h", cache.lazy = TRUE,
                      out.width = "70%")
theme_set(theme_bw(base_size=12))
```

```{r JEPXdata, message=FALSE}
load("data/JEPX_price.RData")

# Use every 7 observations (weekly averages)
jepx <- jepx %>%
  mutate(n = n %/% 7) %>% 
  group_by(n) %>% 
  summarise(date = min(date), lprice = mean(lprice))

mod <- lm(lprice ~ (sin(2*pi*n/25.8) + cos(2*pi*n/25.8))*poly(n, degree = 3), jepx)
jepx <- jepx %>%
  mutate(lprice_resid = mod$residuals, lprice_fit = mod$fitted.values)
```

```{r NuukData, message=FALSE}
Nuuk <- read_table2("data/nuuk.dat.txt", 
                    col_names = c("Year", 1:12), 
                    na = "-999", 
                    skip = 1) %>% 
  gather(key = "Month", value = "Temperature", -Year, convert = TRUE) %>% 
  mutate(Temperature = Temperature / 10) %>% 
  filter(Year > 1866)
Nuuk_year <- group_by(Nuuk, Year) %>% 
  summarise(
    Temperature = mean(Temperature),
    Median = median(Temperature),
    High = max(Temperature), 
    Low = min(Temperature)
  )
n <- nrow(Nuuk_year)
```

Form dataframe. Can select from `Nuuk_year` or `jepx`.

```{r}
x <- Nuuk_year$Year
y <- Nuuk_year$Temperature

df <- tibble(x, y)
```


```{r}
pp <- ggplot(df, aes(x, y)) +
  geom_point()
pp
```

## Splines

Given points $\{(x_1,y_1), \dots, (x_n, y_n)\}$, we want to implement the smoother which solves
\[
\min_{f \in C^2}\quad L(f) = \sum_{i=1}^n\big(y_i - f(x_i)\big)^2 + \lambda \|f''\|_2^2
\]
All solutions belong to the $n$-dimensional vector space consisting of cubic splines with knots in $\mathbf x = (x_1, \dots, x_n)$, independently of $\mathbf y$. Thus all candidate solutions can be written
\[
f = \sum_{i=1}^n \beta_i \varphi_i
\]
for a basis $\varphi_1, \dots, \varphi_n$ of cubic splines, or more concisely $\mathbf f = \boldsymbol \Phi \beta$ for $\mathbf f = (f(x_1), \dots, f(x_n))$ and $\boldsymbol \Phi_{ij} = \varphi_j(x_i)$. We use this to rewrite the loss function as
\[
L(f) = (\mathbf y - \boldsymbol \Phi\beta)'(\mathbf y - \boldsymbol \Phi\beta) + \lambda\beta'\boldsymbol \Omega\beta
\]
where
\[
\boldsymbol \Omega_{ij} = \langle\varphi_i'', \varphi_j''\rangle = \int \varphi_i''\varphi_j''\, dm.
\]
The minimizer is given by
\[
\hat{\mathbf{f}} = \boldsymbol\Phi(\boldsymbol\Phi'\boldsymbol\Phi + \lambda\boldsymbol\Omega)^{-1}\boldsymbol\Phi'\mathbf y \equiv \mathbf S_\lambda\mathbf y.
\]
We must overcome two computational challenges, namely 1) how to evaluate $\boldsymbol\Omega$ and 2) how to efficiently calculate $\mathbf S_{\lambda}$.

First, we find a function to evaluate $\boldsymbol\Omega$. From CSwR, using Simpson's rule:

```{r}
pen_mat <- function(inner_knots) {
  knots <- sort(c(rep(range(inner_knots), 3), inner_knots))
  d <- diff(inner_knots)  # The vector of knot differences; b - a 
  g_ab <- splineDesign(knots, inner_knots, derivs = 2) 
  knots_mid <- inner_knots[-length(inner_knots)] + d / 2
  g_ab_mid <- splineDesign(knots, knots_mid, derivs = 2)
  g_a <- g_ab[-nrow(g_ab), ]
  g_b <- g_ab[-1, ]
  (crossprod(d * g_a,  g_a) + 
      4 * crossprod(d * g_ab_mid, g_ab_mid) + 
      crossprod(d * g_b, g_b)) / 6 
}
```

We are now ready to write our first (slow) smoother function:

```{r}
Phi <- splineDesign(c(rep(range(x), 3), x), x)
Omega <- pen_mat(x)
  
smoother <- function(lambda) {
  Phi %*% solve(
    crossprod(Phi) + lambda * Omega, 
    t(Phi) %*% y
  )
}
```


```{r}
gcv <- function(lambda) {
  S <- Phi %*% solve(crossprod(Phi) + lambda * Omega, t(Phi))
  df <- sum(diag(S))  # The trace of the smoother matrix
  sum(((y - S %*% y) / (1 - df / length(y)))^2, na.rm = TRUE) 
}

lambda <- seq(50, 250, 2)
GCV <- sapply(lambda, gcv)
lambda_opt <- lambda[which.min(GCV)]
qplot(lambda, GCV) + geom_vline(xintercept = lambda_opt, color = "red")
```

We can test that this works:

```{r}
pp + geom_line(aes(y = smoother(lambda_opt)), col = "red")
```

Steps for efficient calculation of $\mathbf S_\lambda = \boldsymbol\Phi(\boldsymbol\Phi'\boldsymbol\Phi + \lambda\boldsymbol\Omega)^{-1}\boldsymbol\Phi'$

1. Single-value decomposition $\Phi = UDV'$.

2. Diagonalize the matrix $D^{-1}V'\Phi VD^{-1} = W\Gamma W'$.

3. Then 
\begin{equation}\label{eq:S_decomp}
\mathbf S_\lambda = \widetilde U(I + \lambda \Gamma)^{-1}\widetilde U'
\end{equation}
for $\widetilde U = UW$.

Step-by-step version for implementation:

- First, the coefficients $\hat\beta = \widetilde U'y$ are computed for expanding $y$ in the basis given by the columns of $\widetilde U$.

- Second, the $i$-th coefficient is shrunk towards $0$,
\[
\hat\beta_i(\lambda) = \frac{\hat\beta_i}{1+\lambda\gamma_i}.
\]

- Third, the smoothed values $\widetilde U\hat\beta_i(\lambda)$ are computed as an expansion using the shrunken coefficients.

```{r}
p <- 20
inner_knots <- seq(min(x), max(x), length.out = p-2)
Phi <- splineDesign(c(rep(range(inner_knots), 3), inner_knots), x)
Omega <- pen_mat(inner_knots)

Phi_svd <- svd(Phi)
Omega_tilde <- t(crossprod(Phi_svd$v, Omega %*% Phi_svd$v)) / Phi_svd$d
Omega_tilde <- t(Omega_tilde) / Phi_svd$d
Omega_tilde_svd <- svd(Omega_tilde)  
U_tilde <- Phi_svd$u %*% Omega_tilde_svd$u

# Decomposition, but fast
f_hat <- t(U_tilde) %*% y
f_hat <- f_hat / (1 + lambda_opt*Omega_tilde_svd$d)
f_hat <- U_tilde %*% f_hat


pp + geom_line(aes(y = f_hat), col = "red")
```

Warning: When $n < p$, the decomposition does not hold! This is why the splines diverge.

```{r, out.width = "100%", warning = FALSE}
plot_cols <- function(S, col_vec = 1:ncol(S)) {
  S %>% as_tibble() %>% mutate(n = row_number()) %>% pivot_longer(-n) %>% 
  mutate(name = str_replace(name, "V", ""),
         name = factor(name, levels = unique(name))) %>% 
  filter(name %in% col_vec) %>% 
  ggplot(aes(x = n, y = value, col = name)) +
  geom_line() +
  facet_wrap(~ name) +
  theme(legend.position = "none")
}

plot_cols(U_tilde)
```


